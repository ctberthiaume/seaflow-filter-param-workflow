---
title: "1µ Bead location workflow"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r}
renv::activate(".")
library(magrittr)
```

```{r}
# Modify here to set inputs and outputs
inst <- "740"
cruise <- "beadtest"
evt_path <- "evt/2014-07-04T00-03-02+00-00.gz"
csv_path <- "filter_params.csv"

min_d1 <- 0
min_d2 <- 0
width <- 5000
```

```{r}
#' Plot helpful cytograms for estimating the D1, D2 and FSC coordinates of the inflection point (corresponds to location of 1µm beads).
#'
#' @param dataframe containing EVT data.
#' @return D1, D2 and fsc values of presumed 1 µm beads
#' @export
inflection.point <- function(DF) {
  QUANTILES <- c(2.5, 50.0, 97.5)

  def_par <- par(no.readonly = TRUE) # save default, for resetting...
  par(mfrow = c(1,3), pty = 's')

  popcycle::plot_cyt(DF, "fsc_small", "pe")

  poly_beads <- splancs::getpoly(quiet = TRUE)
  b <- subset(DF, splancs::inout(as.matrix(DF[, c("fsc_small", "pe")]), poly = poly_beads, bound = TRUE, quiet = TRUE))

  popcycle::plot_cyt(b, "fsc_small", "D1")
  abline(h = 29000, lwd = 1, col = 'red3')
  abline(v = 44500, lwd = 1, col = 'red3')

  polyd1 <- splancs::getpoly(quiet=TRUE)
  opp.d1 <- subset(b,splancs::inout(b[, c("fsc_small", "D1")], poly = polyd1, bound = TRUE, quiet = TRUE))

  popcycle::plot_cyt(b, "fsc_small", "D2")
  abline(h = 29000, lwd = 1, col = 'red3')
  abline(v = 44500, lwd = 1, col = 'red3')

  polyd2 <- splancs::getpoly(quiet=TRUE)
  opp.d2 <- subset(b, splancs::inout(b[, c("fsc_small", "D2")], poly = polyd2, bound = TRUE, quiet = TRUE))

  FSC <- round(summary(c(opp.d1$fsc_small, opp.d2$fsc_small)))
  D1 <- round(summary(opp.d1$D1))
  D2 <- round(summary(opp.d2$D2))

  inflection <- data.frame()
  for (quant in QUANTILES) {
    if (quant == 2.5) {
      i <- 2; j <- 5
    } else if (quant == 50.0) {
      i <- j <- 3
    } else if (quant == 97.5) {
      i <- 5; j <- 2
    }
    fsc <- as.vector(FSC[i])
    d1 <- as.vector(D1[j])
    d2 <- as.vector(D2[j])
    newrow <- data.frame(quantile = quant, fsc, d1, d2, stringsAsFactors = FALSE)
    inflection <- rbind(inflection, newrow)
  }
  par(def_par)

  return(inflection)
}


create.filter.params <- function(inst, fsc, d1, d2, min.d1, min.d2, width = width, slope.file = NULL) {
  QUANTILES <- c(2.5, 50.0, 97.5)

  # Rename to get correct dataframe headers
  beads.fsc.small <- as.numeric(fsc)
  beads.D1 <- as.numeric(d1)
  beads.D2 <- as.numeric(d2)
  min.D1 <- as.numeric(min.d1)
  min.D2 <- as.numeric(min.d2)

  width <- as.numeric(width)

  if (is.null(slope.file)) {
    slope.file <- "https://raw.githubusercontent.com/armbrustlab/seaflow-virtualcore/master/1.bead_calibration/seaflow_filter_slopes.csv"
  }
  slopes <- read.csv(slope.file)

  filter.params <- data.frame()
  headers <- c(
    "quantile", "beads.fsc.small",
    "beads.D1", "beads.D2", "width",
    "notch.small.D1", "notch.small.D2",
    "notch.large.D1", "notch.large.D2",
    "offset.small.D1", "offset.small.D2",
    "offset.large.D1", "offset.large.D2"
  )
  for (quant in QUANTILES) {
    if (quant == 2.5) {
      suffix <- "_2.5"
      i <- 1
    } else if (quant == 97.5) {
      suffix <- "_97.5"
      i <- 3
    } else if (quant == 50.0) {
      suffix <- ""
      i <- 2
    }

    # Small particles
    offset.small.D1 <- min.D1
    offset.small.D2 <- min.D2
    notch.small.D1 <- round((beads.D1[i]-min.D1)/beads.fsc.small[i],3)
    notch.small.D2 <- round((beads.D2[i]-min.D2)/beads.fsc.small[i],3)

    # Large particles
    notch.large.D1 <- round(slopes[slopes$ins == inst, paste0('notch.large.D1', suffix)], 3)
    notch.large.D2 <- round(slopes[slopes$ins == inst, paste0('notch.large.D2', suffix)], 3)
    offset.large.D1 <- round(beads.D1[i] - notch.large.D1 * beads.fsc.small[i])
    offset.large.D2 <- round(beads.D2[i] - notch.large.D2 * beads.fsc.small[i])

    newrow <- data.frame(
      quant, beads.fsc.small[i],
      beads.D1[i], beads.D2[i], width,
      notch.small.D1, notch.small.D2,
      notch.large.D1, notch.large.D2,
      offset.small.D1, offset.small.D2,
      offset.large.D1, offset.large.D2,
      stringsAsFactors=FALSE
    )
    names(newrow) <- headers
    filter.params <- rbind(filter.params, newrow)
  }

  return(filter.params)
}
```

```{r}
# Read EVT
evt <- popcycle::readSeaflow(evt_path, transform = F)
```

```{r}
#Check EVT cytograms
# popcycle::plot_cytogram(DF, "D1", "D2", transform = F)
# popcycle::plot_cytogram(DF, "fsc_small", "D1", transform = F)
# popcycle::plot_cytogram(DF, "fsc_small", "D2", transform = F)
popcycle::plot_cytogram(evt, "fsc_small", "pe", transform = F)
# popcycle::plot_cytogram(DF, "fsc_small", "chl_small", transform = F)
```

```{r}
################################################################################
### GET D1, D2 and FSC coordinate of inflection point (where 1 µm beads are) ###
################################################################################
ip <- inflection.point(evt)
```

```{r}
filter.params <- create.filter.params(
  inst,
  fsc = ip$fsc,
  d1 = ip$d1,
  d2 = ip$d2,
  min.d1 = min_d1,
  min.d2 = min_d2,
  width = width
)
```

```{r}
popcycle::plot_filter_cytogram(evt, filter.params)
```

```{r}
par(mfrow=c(2,2))
opp <- popcycle::filter.notch(evt, filter.params)

popcycle::plot_cyt(opp, "fsc_small", "chl_small")

popcycle::plot_cyt(opp, "fsc_small", "pe")
abline(v = filter.params[,'beads.fsc.small'], lty = 2,col = 2)

b <- subset(opp, pe > 40000)
popcycle::plot_cyt(b, "fsc_small", "D1")
abline(h = filter.params[,'beads.D1'], lty = 2, col = 2)

popcycle::plot_cyt(b, "fsc_small", "D2")
abline(h = filter.params[,'beads.D2'], lty = 2, col = 2)
```

```{r}
# only if satisfied with filter params
write.csv(data.frame(instrument = inst, cruise, filter.params), csv_path, quote = F, row.names = F)
```